---
# Rule Definition Metadata (V1)
ruleId: execution-loop
ruleType: Procedure
title: Core Execution Loop (Log-Driven, Non-Stop)
description: Defines the mandatory, sequential, log-driven steps each agent MUST follow during its execution turn, enabling continuous, autonomous operation.
schemaVersion: 1
conformsTo: null
tags: [core, framework, procedure, execution, agent-turn, log-driven, autonomous]
lastUpdated: null # Update timestamp if needed
status: Active
---

# üîÅ Core Execution Loop (Indestructible & ACTION-DRIVEN)

## 1. PURPOSE & OBJECTIVES

This document outlines the **single, mandatory sequence of actions** that every agent MUST perform during its active execution cycle within a `requestId`. This loop **commands** the **non-stop execution flow**. Adherence ensures consistent context handling, state updates via logs, and **immediate, automatic transitions** based solely on the `nextAgent` field in the log file.

## 2. CORE BEHAVIOR (Applies to ALL agents)

Agents operate continuously within an active `requestId`. They are activated based on the `nextAgent` field in the latest log entry (`logs/<requestId>.json`). Within their execution cycle, they MUST perform the following 10 steps **sequentially and without deviation**, using the log file as the primary coordination mechanism. Agents transition **immediately and automatically** based on the logged `nextAgent`.

***ACTION IMPERATIVE:** The rules defined here **command immediate, non-stop, automatic transitions** between agents triggered **solely** by the logged `nextAgent` field. The framework **must execute** transitions without pausing for user input. Any observed pause **violates** this core imperative.*\

## 3. ACTION SEQUENCE (MANDATORY)

### Step 1: ACTION - Load context
*   **Action:** Load current state and context from the request-specific log file.
*   **Tooling:** `read_file`.
*   **Input:** `requestId`.
*   **Process:** Target `logs/<requestId>.json`. Parse the latest entry to extract current state (`projectName`, `domain`, `handoffMessage`, `observations`, etc.). Optionally use `python rules/tools/analyze_log.py logs/<requestId>.json` (`run_terminal_cmd`).
*   **Verification:** Log file exists and is readable.

### Step 2: ACTION - Get MCP task (Optional & Restricted)
*   **Action:** Query the Task Manager for the next task, if applicable to the agent's role and current state. This is a non-blocking check.
*   **Tooling:** `mcp_taskmanager_get_next_task`.
*   **Input:** `requestId`.
*   **Process:** Initiate the call. Execution **MUST NOT** block waiting for a response; log state drives the primary flow. Integrate task info if received promptly.
*   **Verification:** Tool call initiated.

### Step 3: ACTION - Analyze Request Log Context
*   **Action (Internal):** Determine the specific goal for this agent's current execution cycle based on the log.
*   **Input:** State extracted in Step 1 (esp. `handoffMessage`, `observations`).
*   **Process:** Analyze the handoff instructions and accumulated observations to define the immediate objective.

### Step 4: ACTION - Analyze Codebase Context
*   **Action:** Gather necessary information from the project codebase.
*   **Tooling:** `file_search`, `read_file`, `grep_search`, `codebase_search`.
*   **Input:** Goal from Step 3, `projectName`.
*   **Process:** Execute necessary tool calls to understand relevant code sections, dependencies, or file structures.

### Step 5: ACTION - Gather External Context (If Needed & Restricted)
*   **Action:** Retrieve external information if required by the task (e.g., documentation, standard patterns).
*   **Tooling:** `context7_*`, `web_search`.
*   **Input:** Goal from Step 3, relevant libraries/topics.
*   **Process:** Use tools to fetch library documentation or search the web for specific error patterns, APIs, etc. Use sparingly.

### Step 6: ACTION - Execute Agent-Specific Action
*   **Action:** Perform the agent's primary function(s) based on its role and the current goal.
*   **Tooling:** Authorized tools per role spec (`edit_file`, `run_terminal_cmd`, custom tools via `python rules/tools/...`, etc.).
*   **Input:** Goal from Step 3, context from Steps 1, 4, 5.
*   **Process:** Execute core tasks (e.g., modify code, run builds, perform analysis, generate docs).
*   **Diagnostics Exception:** If execution fails and *requires* specific external information (e.g., user-provided logs, HAR files) to proceed, the agent MAY log a request for this data and set `nextAgent` to `Overmind`. **DO NOT** pause or wait for direct user interaction otherwise.

### Step 7: ACTION - Prepare Findings / Record Actions
*   **Action (Internal):** Consolidate the results and summaries of actions taken during this cycle.
*   **Input:** Outputs and status from tool calls in Steps 4, 5, 6.
*   **Process:** Structure the key findings, code changes made (or planned), errors encountered, and diagnostics gathered into a format suitable for logging (`actionsTaken` structure).

### Step 8: ACTION - Finalize Task (If Applicable - Non-Blocking & Restricted)
*   **Action:** If the agent's action completes a specific MCP task, mark it as done. This is non-blocking.
*   **Tooling:** `mcp_taskmanager_mark_task_done`.
*   **Input:** `requestId`, relevant `taskId`.
*   **Process:** Initiate the tool call. **Immediately proceed** to Step 9 without waiting for confirmation. Task approval happens externally via user interaction prompted by MCP tooling display, not by agent pausing.

### Step 9: Log To Request File (CRITICAL for IMMEDIATE Handoff)
*   **Action:** Append the execution cycle's results and determine the next agent. **THIS IS THE HANDOFF TRIGGER.**
*   **Tooling:** `edit_file` (or equivalent log append mechanism).
*   **Input:** `requestId`, findings from Step 7, determined `nextAgent`, `handoffMessage`.
*   **Process:**
    1.  Determine the `nextAgent` role (e.g., `BuilderAgent`, `AuditAgent`, `Overmind`) based on the outcome, workflow state, and agent's transfer conditions. Can be a direct peer-to-peer handoff or return to `Overmind`. Set to `null` or `"HALT"` ONLY on irrecoverable failure or explicit completion signal.
    2.  Formulate the `handoffMessage` for the next agent.
    3.  Construct the JSON log entry including `nextAgent`, `handoffMessage`, `actionsTaken`, timestamp, agent role, etc.
    4.  **Append** this entry to `logs/<requestId>.json`.
*   **Verification:** Log entry is correctly formatted and appended. **`nextAgent` MUST BE SET.**

### Step 10: Automatic Transition (IMMEDIATE Framework Action)
*   **Action:** The framework takes over based *solely* on the `nextAgent` logged in Step 9.
*   **Process:**
    1.  Framework **IMMEDIATELY** reads the latest entry in `logs/<requestId>.json`.
    2.  If `nextAgent` is a valid agent role: Framework **MUST automatically load rules** for that agent and restart execution from Step 1 **with the designated agent without any delay or user interaction**.
    3.  If `nextAgent` is null, empty, or `"HALT"`: Execution stops for this `requestId`.
    4.  If `nextAgent` is invalid/missing: Framework reports error and halts.
*   **Outcome:** The current agent's execution cycle ends implicitly. The framework handles the transition.

## 4. INPUTS & OUTPUTS

*   **Input:** Request Log (`logs/<requestId>.json`), Agent's own Role Specification (`.mdc`).
*   **Output:** Updated Request Log (`logs/<requestId>.json`) with new entry containing `nextAgent`.

## 5. TOOLS (Common Pool)

*   `read_file`
*   `edit_file` / Log Append Mechanism
*   `run_terminal_cmd` (for system commands and custom `tools/*.py` scripts)
*   `mcp_taskmanager_*` (esp. `get_next_task`, `mark_task_done`)
*   `file_search`, `grep_search`, `codebase_search`
*   `context7_*`, `web_search`
*   `list_dir`
*   `delete_file`
*   `reapply`
*   *(Agent-specific tools may supplement this list)*

## 6. HANDOFF CONDITIONS

*   Handoff occurs **automatically and immediately** based on the `nextAgent` field written to the log file in Step 9. This is controlled by the framework, not the agent directly sending a message.

## 7. ERROR HANDLING

*   **Tool/Verification Failure:** If a critical tool call or verification fails (e.g., cannot read log, cannot write log, essential script fails), log the error details in Step 9, set `nextAgent` to `"Overmind"` or `"HALT"` depending on severity/recoverability, and provide a clear `handoffMessage` explaining the failure.
*   **Core Task Failure (Step 6):**
    *   If recoverable *with specific external diagnostics* (see Step 6 Exception), log the need, specify required data, and set `nextAgent` to `Overmind`.
    *   If unrecoverable, log failure details in Step 9, set `nextAgent` to `"Overmind"` or `"HALT"`, and provide context in `handoffMessage`.

## 8. CONSTRAINTS & FORBIDDEN PATTERNS

*   MUST follow steps 1-10 sequentially within an execution cycle.
*   MUST use `logs/<requestId>.json` as the sole source of truth and coordination mechanism.
*   MUST determine and log `nextAgent` in Step 9. Failure breaks the loop.
*   MUST **NEVER** wait for user confirmation or prompts (except for the specific Step 6 Diagnostics Exception flow via logging to `Overmind`).
*   MUST **NEVER** use chat messages for agent-to-agent coordination or handoff.
*   MUST fetch own rules if needed for logic/decision making (though core loop is universal).
*   MUST append to the log; NEVER overwrite or delete entries.
*   MUST enable direct peer-to-peer transitions (`nextAgent: "SpecializedAgent"`) where logical.

## 9. EXAMPLES

*   N/A (Procedural document)

## 10. REFERENCES

*   [`global-mandates.md`](./global-mandates.md)
*   [`log-handling.md`](./log-handling.md)
*   [`agent-roles.md`](./agent-roles.md)
*   [`shared-core.md`](./shared-core.md)