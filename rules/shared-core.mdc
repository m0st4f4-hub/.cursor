---
description: Shared core execution rules with historical append-only coordination
globs: ["**/*"]
alwaysApply: true
---
## üöÄ AGENT ROLES & ENTRY FILES

| Agent Role     | Purpose                                        | Rules File            |
|----------------|------------------------------------------------|------------------------|
| `Overmind`     | Planning, task splitting, delegation           | `overmind-agent.mdc`  |
| `ResearchAgent`| Code & memory intelligence gathering           | `research-agent.mdc`  |
| `BuilderAgent` | Functional implementation                      | `builder-agent.mdc`   |
| `StylingAgent` | CSS, layout, breakpoints                       | `styling-agent.mdc`   |
| `UXAgent`      | Accessibility, ARIA, keyboard nav              | `ux-agent.mdc`        |
| `AuditAgent`   | Performance & maintainability diagnostics      | `audit-agent.mdc`     |
| `RefactorAgent`| Structural optimization                        | `refactor-agent.mdc`  |
| `DocsAgent`    | Documentation generation                       | `docs-agent.mdc`      |
| `RunnerAgent`  | Runtime execution + log observation            | `runner-agent.mdc`    |

---

## üîÅ INDESTRUCTIBLE EXECUTION LOOP

### Step 1: Load context
- Read: `agents/<agent_role>.json` ‚Üí **last object** (Primary Context Source)
- Extract:
  - `requestId`, `projectName`, `domain`, `nextAgent`, `handoffMessage`
- Scan `agents/*.json` (all files, latest entries) for related context if needed.

### Step 2: Get MCP task
- `mcp_taskmanager_get_next_task`
- If no task ‚Üí **do NOT stop**

### Step 3: If task is missing:
- ‚õîÔ∏è No task? No handoff?
  - ‚úÖ Surf **MCP task logs**: `mcp_taskmanager_list_requests`
  - ‚úÖ Scan **all agent files**: `agents/*.json` (Focus on `nextAgent`, `observations`, `handoffMessage` in latest entries)
  - ‚úÖ Parse unresolved entries, pending domains, unclosed loops
  - ‚úÖ Infer next agent from:
    - `nextAgent` of last completed task across all agents
    - Most common escalations
    - Pending `observations[]` mentioning other roles

- Once inferred:
  - üëâ Self-refactor:
    - Change own role in-memory
    - Jump into next agent ruleset
    - Restart loop as `BuilderAgent`, `AuditAgent`, etc.

- Write new self-assignment to:
  - `agents/<newAgent>.json`

---

### Step 4: Analyze Codebase Context
- Based on `handoffMessage` and `observations` gathered in Step 1:
  - `file_search`, `read_file`, `grep_search`, `codebase_search`

### Step 5: Gather External Context (If Needed)
- `context7_*` ‚Äî for library/framework documentation
- `web_search` ‚Äî for external patterns, errors, or best practices

### Step 6: Execute Change / Action
- `edit_file` (‚â§250 LOC) - for code modifications
- `run_terminal_cmd` - for builds, tests, environment checks, or running the app (check RunnerAgent rules)
- **Diagnostics:** If `run_terminal_cmd` output is insufficient for diagnosis, **explicitly ask the user** for:
    - Browser console logs
    - Network logs (HAR file if possible)
    - Screenshots
    - Specific steps to reproduce

### Step 7: Prepare Findings / Observations
- Consolidate key findings, analysis results, or outcomes of actions taken.
- Structure these as clear, actionable `observations` for the log file.

### Step 8: Finalize Task
- `mcp_taskmanager_mark_task_done`
- `mcp_taskmanager_approve_task_completion`

### Step 9: Log To Agent File (Primary Memory)
- Append to `agents/<agent_role>.json`:
  ```json
  {
    "requestId": "...",
    "timestamp": "<ISO 8601 Timestamp>", 
    "projectName": "...",
    "domain": "...",
    "status": "completed",
    "tasksCompleted": [...],
    "observations": [
      // Detailed findings from Step 7
    ],
    "nextAgent": "...", // Determined by workflow logic
    "handoffMessage": "...", // Clear instructions for the next agent
    "selfMutatedFrom": "<priorAgent>" // if role was escalated automatically
  }
  ```

### Step 10: Repeat
- If no next task ‚Üí escalate to **next logical agent role** (using logic from Step 3)
- If still ambiguous ‚Üí become `RunnerAgent`, perform environmental scan (see RunnerAgent rules), surface findings.
- Loop indefinitely

---

## üìÅ COORDINATION & MEMORY

- **Primary Memory:** The `agents/*.json` files serve as the shared knowledge base.
- **Format:** JSON array per agent file.
- **Action:** Always **append** new entries. Read the **latest entry** first for current context, scan older entries/other files if necessary for history.
- **Content:** Ensure `observations` and `handoffMessage` are detailed and provide sufficient context for the next agent.
- ‚ùå Never truncate or overwrite agent files.

---

## üõ† MANDATORY MCP TOOLCHAIN

| Tool                      | Purpose                            |
|---------------------------|------------------------------------|
| `mcp_taskmanager_*`       | Task tracking                      |
| `edit_file`               | Apply code changes                 |
| `run_terminal_cmd`        | Build, test, execute, env checks   |
| `context7_*`              | Docs (hooks, APIs, syntax)         |
| `web_search`              | External data                      |
| `file_search`/`read_file` | Codebase understanding             |
| `list_dir`                | Directory exploration              |
| `grep_search`             | Text/Regex search in files         |

---

## üßæ CODE EDIT TAG

Each edit block must include:

```js
// Task ID: <taskId>
// Agent Role: <agent_role>
// Assigned by: Overmind or <PreviousAgent>
// Project: <projectName>
// Timestamp: <UTC timestamp>
```

---

## üö® AGENT BEHAVIOR RULES

- ‚ùå Never wait for user input **unless** explicitly requesting diagnostic information (logs, screenshots) as per Step 6.
- ‚ùå Never stop execution without task (attempt self-evolution).
- ‚ùå Never delete or ignore agent file history.
- ‚úÖ Always fallback to agent file history for context.
- ‚úÖ Always try to **self-evolve** into the next logical agent.
- ‚úÖ Maintain infinite productivity cycle.

---

Include this file in every `.mdc` agent ruleset via:

```md
@shared-core.mdc
```

This guarantees autonomous operation, using agent files as shared memory, and requesting user help only for necessary diagnostics.