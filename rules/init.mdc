---
# Rule Definition Metadata (V1)
ruleId: initialization-procedure
ruleType: Procedure
title: Initialization Procedure (Mandatory)
description: MANDATORY procedure for `InitializationAgent` to configure `.cursor/rules/` via Git submodule or clone.
schemaVersion: 1
conformsTo: null
tags: [core, framework, procedure, initialization, setup, ruleset, agent-initialization]
lastUpdated: null
status: Active
---

# ✨ Initialization Procedure (Mandatory)

**Purpose:** You will use this procedure to ensure the `.cursor/` ruleset directory exists and is correctly configured in the current project.
**Executor:** This procedure **MUST** be executed by the `InitializationAgent`.
**Context:** You (as `InitializationAgent`) are triggered by `Overmind` (via Chat or MCP). You **MUST** fetch your own rules (`initialization-agent.md`) before starting this procedure.

**Principles You MUST Follow:**
*   **Idempotency:** You **MUST** perform actions such that repeated execution of this procedure yields the same valid end state.
*   **Verification:** You **MUST** confirm the success or failure of each critical step using tool outputs (`list_dir`, `read_file`, `git status`, etc.), **NOT** by relying solely on command exit codes. You **MUST** document the outcomes of your verification checks in your final report.
*   **Error Handling:** If any verification step fails, you **MUST HALT** this procedure immediately and report the specific error details to `Overmind` (via the appropriate mechanism, likely an MCP task update or a Chat Trigger).
*   **Tool Usage:** You **MUST** use only standard tools and Git commands as specified herein.
*   **Reporting:** In your final report to `Overmind`, you **MUST** include a summary of actions taken, any warnings encountered, verification results, and the final status (success or failure point).

## Your Workflow (Mandatory Steps)

### Phase 0: Get Context

1.  **Fetch Your Rules:** You **MUST** execute `fetch_rules` for `initialization-agent.md`.
2.  **Parse Context:** You **MUST** extract the `requestId` and any other relevant context from the incoming Chat Trigger or MCP Task details.

### Phase 1: Determine Project State

1.  **Check Git Status:**
    *   You **MUST** verify Git is available (e.g., by running `python tools/verify_environment.py --check git`).
    *   You **MUST** check if the current directory is inside a Git repository (e.g., using `python tools/parse_git_status.py` or `git rev-parse --is-inside-work-tree`).
    *   You **MUST** record the result as `isGitRepo` (boolean).
2.  **Check `.cursor` Directory Existence:**
    *   You **MUST** execute `list_dir .`.
    *   You **MUST** record the result as `cursorDirExists` (boolean).
3.  **Check if Directory is Empty (Only if Not a Git Repo):**
    *   *Condition:* You will perform this check only if `isGitRepo` is false.
    *   You **MUST** execute `list_dir .` again. You will check if the listing contains *any* files or folders other than potentially a `.cursor` or `.git` directory.
    *   You **MUST** record the result as `isNotEmpty` (boolean).

### Phase 2: Execute Scenario Workflow

➡️ **Scenario A: Git Repository (`isGitRepo` is true)**
1.  **Handle Existing `.cursor` Directory:**
    *   IF `cursorDirExists` is true:
        *   You **MUST** execute `run_terminal_cmd git submodule status .cursor`.
        *   IF the output indicates it's a valid Git submodule: GOTO Step A.4.
        *   IF it is not a submodule or the command errors: You will log a warning internally. You **MUST** attempt to remove the existing directory by executing `run_terminal_cmd rm -rf .cursor` (or `Remove-Item -Recurse -Force .cursor` on Windows). You **MUST** verify its removal using `list_dir .`. IF verification fails, you **MUST HALT & REPORT** the failure. Then, GOTO Step A.2.
    *   ELSE (`cursorDirExists` is false): GOTO Step A.2.
2.  **Check/Modify Root `.gitignore`:**
    *   You will set an internal flag: `rootGitignoreModified = false`.
    *   You **MUST** execute `read_file .gitignore`. Handle the case where the file might not exist gracefully.
    *   Search the content for the exact line `.cursor/` (not commented out).
    *   IF the exact line `.cursor/` is found:
        *   You **MUST** execute `edit_file .gitignore` to comment out the line (e.g., changing it to `# .cursor/`). You will log this action internally.
        *   Set your internal flag: `rootGitignoreModified = true`.
        *   You **MUST** verify the change by executing `read_file .gitignore` again. IF verification fails, you **MUST HALT & REPORT** the failure.
    *   GOTO Step A.3.
3.  **Add Submodule:**
    *   You **MUST** execute `run_terminal_cmd git submodule add https://github.com/m0st4f4-hub/.cursor .cursor`.
    *   **Verify:**
        *   You **MUST** execute `list_dir .`. Confirm that both `.cursor` AND `.gitmodules` now exist.
        *   You **MUST** execute `read_file .gitmodules`. Confirm it contains an entry for `[submodule ".cursor"]`.
        *   *If Verification Fails:* If the failure seems related to a pre-existing conflicting state (e.g., you just removed an old directory in Step A.1), you **MUST** attempt the command `run_terminal_cmd git submodule add --force https://github.com/m0st4f4-hub/.cursor .cursor` **ONCE**. If it still fails after the force attempt, you **MUST HALT & REPORT** the failure.
    *   GOTO Step A.4.
4.  **Update Submodule:**
    *   You **MUST** execute `run_terminal_cmd git submodule update --init --recursive`.
    *   **Verify:** You **MUST** execute `list_dir .cursor/rules`. Confirm critical rule files (e.g., `@system.md`) are present. If verification fails, you **MUST** retry the `git submodule update --init --recursive` command **ONCE**. If it still fails, you **MUST HALT & REPORT** the failure.
    *   GOTO Phase 3.

➡️ **Scenario B: Non-Git, Empty Directory (`isGitRepo` is false, `isNotEmpty` is false)**
1.  **Handle Existing `.cursor` Directory:**
    *   IF `cursorDirExists` is true: You will log a warning internally. You **MUST** execute `run_terminal_cmd rm -rf .cursor` (or `Remove-Item -Recurse -Force .cursor`). You **MUST** verify removal using `list_dir .`. IF verification fails, **HALT & REPORT**.
    *   GOTO Step B.2.
2.  **Direct Clone:**
    *   You **MUST** execute `run_terminal_cmd git clone https://github.com/m0st4f4-hub/.cursor .cursor`.
    *   **Verify:** You **MUST** execute `list_dir .cursor/rules`. Confirm critical rule files exist. If verification fails, **HALT & REPORT**.
    *   GOTO Phase 3.

➡️ **Scenario C: Non-Git, Not Empty Directory (`isGitRepo` is false, `isNotEmpty` is true)**
*   **WARNING:** This scenario likely requires manual user intervention if `.cursor` already exists.
1.  **Handle Existing `.cursor` Directory:**
    *   IF `cursorDirExists` is true: You **MUST HALT & REPORT**. Your report state should be: "Non-Git project contains an unexpected `.cursor` directory that was not placed by this procedure. Manual intervention is required."
    *   ELSE (`cursorDirExists` is false): You **MUST HALT & REPORT**. Your report state should be: "Cannot automatically clone rules into a non-empty directory that is not a Git repository. Please initialize Git first or clean the target directory."

### Phase 3: Final Verification & Reporting

1.  **Final Check:** You **MUST** execute `list_dir .cursor/rules`. You **MUST** also `read_file` a key rule file (e.g., `.cursor/rules/system.md`) to confirm the rules directory was populated correctly.
2.  **Report Outcome:** You **MUST** report the final outcome (success, or failure including the specific phase/step/reason and verification details) to `Overmind` using the appropriate mechanism (Chat Trigger or MCP Task Update).

**Error Handling Summary:** Any verification failure marked with **MUST HALT & REPORT** triggers an immediate stop of this procedure and reporting the failure details as described in Phase 3, Step 2.

## REFERENCES

*   [`initialization-agent.md`](./agents/initialization-agent.md)
*   [System Prompt & Mandates](mdc:system.mdc)
*   Git Submodule Documentation (External)