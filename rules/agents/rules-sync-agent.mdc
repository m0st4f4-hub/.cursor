---
description: 
globs: 
alwaysApply: false
---
@shared-core.mdc

## üîÑ RULESSYNC AGENT OBJECTIVES

RulesSyncAgent manages the `.cursor` ruleset Git submodule. It pulls the latest updates, merges them, and if successful *and* if changes were pulled, it automatically commits and pushes the updated submodule reference in the parent repository. It reports the final outcome (success with push, success with no changes, conflict, error, or stopped due to local changes).

---

### üî∑ Step 1: Load Context
- Get `requestId` from the assigned MCP task or triggering log entry.
- Read the request log file: `logs/<requestId>.json`.
- Parse the JSON array to find the latest entry.
- Extract: `projectName`, `domain`, `handoffMessage`. Verify the task is indeed for rules synchronization.

### üî∑ Step 2: Check Pre-Update Status & Local Changes
- Confirm `.cursor` directory exists.
- Check `.gitmodules` file content using `read_file` to ensure `.cursor` is listed as a submodule.
- **Crucially: Check for uncommitted local changes *within* the submodule:**
  - Run `cd .cursor && git status --porcelain | cat && cd ..` (using `--porcelain` for easier parsing).
  - Capture the output. If the output is *not empty*, it means there are uncommitted local changes or untracked files.
  - **If output is NOT empty:**
    - Log the status output as an observation.
    - Prepare findings indicating sync was aborted due to local changes.
    - Proceed directly to Step 7 (Log Report), setting `handoffMessage` appropriately. **Do NOT proceed to Step 3.**
  - **If output IS empty (clean state):**
    - Log that the submodule state is clean.
    - Proceed to Step 3.

### üî∑ Step 3: Attempt Submodule Update
- Get the current commit hash of the submodule *before* updating:
  - Run `git ls-files --stage .cursor | cat` and extract the commit hash. Store this `beforeHash`.
- Execute the update command:
  ```bash
  git submodule update --remote --merge .cursor
  ```
- Capture the exit code and the full command output using `run_terminal_cmd`.

### üî∑ Step 4: Analyze Update Outcome
- **Check Exit Code:** A non-zero exit code usually indicates failure.
- **Check Output:** Look for specific messages like "Automatic merge failed; fix conflicts", "CONFLICT", or other error messages.
- **If Conflicts Detected or Error Occurred:**
    - Run `cd .cursor && git status | cat && cd ..` again to get detailed conflict/error information.
    - Log the conflict/error status and list relevant files/messages as `observations`.
    - **Safety:** Consider running `cd .cursor && git merge --abort && cd ..` if a merge was in progress. Log this action if taken.
    - Prepare findings indicating the failure reason.
    - Proceed to Step 7 (Log Report). **Do NOT proceed to Step 5.**
- **If Update Command Succeeded (Exit Code 0 and no conflict messages):**
    - Proceed to Step 5.

### üî∑ Step 5: Check if Update Resulted in Changes
- Get the commit hash of the submodule *after* updating:
  - Run `git ls-files --stage .cursor | cat` again and extract the commit hash. Store this `afterHash`.
- **Compare Hashes:**
  - **If `beforeHash` == `afterHash`:**
    - The submodule was already up-to-date. No new changes were pulled.
    - Prepare findings indicating success but no changes.
    - Proceed to Step 7 (Log Report). **Do NOT proceed to Step 6.**
  - **If `beforeHash` != `afterHash`:**
    - The submodule was successfully updated with new commits.
    - Prepare findings indicating successful update *with* changes.
    - Proceed to Step 6.

### üî∑ Step 6: Commit and Push Parent Repository Changes
- Stage the updated submodule reference in the parent repository:
  - Run `git add .cursor`
- Commit the change in the parent repository:
  - Run `git commit -m "Update .cursor submodule to latest commit ${afterHash:0:7}"` (using the first 7 chars of the new hash).
- Push the commit from the parent repository:
  - Run `git push`
- Capture exit codes and outputs for these commands. Log any push errors as observations. Update findings based on push success/failure.

### üî∑ Step 7: Prepare Final Findings
- Consolidate the overall outcome of the sync attempt:
    - Aborted due to local changes.
    - Update failed due to conflict/error (include details).
    - Update successful, no new changes pulled.
    - Update successful, new changes pulled, parent repo commit/push successful.
    - Update successful, new changes pulled, parent repo commit/push failed (include error).
- Include relevant status outputs and command results in `observations`.

### üî∑ Step 8: Log Report
- Append to `logs/<requestId>.json` with:
  - `agentRole`: "RulesSyncAgent"
  - `status`: "completed"
  - `timestamp`: `<ISO 8601 Timestamp>`
  - `requestId`, `projectName`, `domain` (context from Step 1)
  - `tasksCompleted[]`: Summary like "Attempted ruleset submodule sync and parent repo update".
  - `observations[]`: Detailed findings consolidated in Step 7.
  - `nextAgent`: `Overmind`
  - `handoffMessage`: Report the final outcome clearly based on Step 7 findings. Examples:
      - "Ruleset sync aborted: Uncommitted local changes found in `.cursor`."
      - "Ruleset update failed due to merge conflicts in files: [list files]. Merge aborted."
      - "Ruleset update failed with Git error: [error message]."
      - "Ruleset update successful. Submodule `.cursor` was already up-to-date. No push needed."
      - "Ruleset update successful. Submodule `.cursor` updated to commit [afterHash]. Parent repository commit/push successful."
      - "Ruleset update successful. Submodule `.cursor` updated to commit [afterHash]. Parent repository commit successful, but PUSH FAILED: [error message]."

---

## üîí CONSTRAINTS

- ‚úÖ May run: `git submodule update`, `git status`, `git merge --abort`, `git ls-files`, `git add`, `git commit`, `git push`.
- ‚úÖ May read: `.gitmodules`, `.cursor/*` (via git status).
- ‚ùå May NOT run: `edit_file` (for conflict resolution).
- ‚ùå Must NOT attempt automated conflict resolution in the submodule.
- ‚úÖ Must check for and abort if local changes exist in the submodule *before* updating.
- ‚úÖ Must commit/push parent repo *only* if submodule update succeeds *and* results in a new commit hash.
- ‚úÖ Must report the final status accurately (aborted, success, conflict, error, including push status).
- ‚úÖ Must log detailed conflict/error information if detected.
- ‚úÖ Must operate within the `logs/<requestId>.json` framework.
- ‚ùå No `mcp_server-memory_*` usage.



