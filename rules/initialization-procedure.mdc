---
# Rule Definition Metadata (V1)
ruleId: initialization-procedure
ruleType: Procedure
title: Ruleset Initialization Procedure
description: Mandatory procedure executed by InitializationAgent to ensure the `.cursor/rules/` directory exists and is correctly configured (via Git submodule or direct clone).
schemaVersion: 1
conformsTo: null
tags: [core, framework, procedure, initialization, setup, ruleset, agent-initialization]
lastUpdated: null
status: Active
---

# INITIALIZATION PROCEDURE (MANDATORY)

**PURPOSE:** Ensure `.cursor/` ruleset exists and is correctly configured. Executed by `InitializationAgent`.

**CONTEXT:** This procedure is executed by the `InitializationAgent` after being activated by a **Chat Trigger** from `Overmind` (e.g., "Hey InitializationAgent, initialize project XYZ."). The agent **MUST** fetch its own rules via `fetch_rules` before proceeding.

**PRINCIPLES (MANDATORY):**
- **IDEMPOTENCY:** Repeated execution MUST yield same valid state.
- **VERIFICATION:** MUST confirm success via tool outputs (`list_dir`, `read_file`, `git status`, `parse_git_status.py`), NOT exit codes.
- **ERROR HANDLING:** On verification failure, MUST append error details to the **Knowledge Wiki** (`## ‚ö†Ô∏è Errors & Escalations`), HALT procedure, and trigger `Overmind` via **Chat Trigger**. See [Error Handling](#error-handling-initialization).
- **TOOL USAGE:** MUST use standard tools/Git commands.
- **WIKI LOGGING:** All significant actions, warnings, and final outcomes **MUST** be appended to the **Knowledge Wiki** under appropriate sections (e.g., `## üõ†Ô∏è Actions & Code Changes`, `## ‚ö†Ô∏è Errors & Escalations`).

## WORKFLOW (MANDATORY)

### Phase 0: Fetch Rules (NEW)
1.  **FETCH OWN RULES:** Execute `fetch_rules` for `initialization-agent.md`.
2.  **READ WIKI:** Execute `read_file` on `<requestId>-wiki.md` for context.

### Phase 1: Determine Project State
1.  **Check Git Status:**
    *   Verify Git availability (e.g., `python tools/verify_environment.py --check git`).
    *   Execute `python tools/parse_git_status.py` or `git rev-parse --is-inside-work-tree | cat`.
    *   Record result: `isGitRepo` (true/false).
2.  **Check `.cursor` Directory Existence:**
    *   Execute `list_dir .`.
    *   Record result: `cursorDirExists` (true/false).
3.  **Check if Directory is Empty (Only if Not a Git Repo):**
    *   *Condition:* Only if `isGitRepo` is false.
    *   Execute `list_dir .`. Check for *any* files or folders other than potentially `.cursor` or `.git`.
    *   Record result: `isNotEmpty` (true/false).

### Phase 2: Execute Scenario Workflow

‚û°Ô∏è **Scenario A: Git Repository (`isGitRepo`: true)**
1.  **HANDLE EXISTING `.cursor`:**
    - IF `cursorDirExists` is true:
        - EXECUTE: `git submodule status .cursor | cat`.
        - IF Valid Submodule: GOTO Step A.4.
        - IF Not Submodule/Error: **Log warning to Wiki.** EXECUTE: `run_terminal_cmd rm -rf .cursor` (or `Remove-Item -Recurse -Force .cursor`). VERIFY removal (`list_dir .`). IF fails, HALT & Escalate. GOTO Step A.2.
    - ELSE (`cursorDirExists` is false): GOTO Step A.2.
2.  **CHECK/MODIFY ROOT `.gitignore`:**
    - SET flag: `rootGitignoreModified = false`.
    - EXECUTE: `read_file .gitignore` (Handle non-existence).
    - SEARCH for exact line `.cursor/`.
    - IF found:
        - EXECUTE: `edit_file .gitignore` (Comment out: `# .cursor/`). **Log action to Wiki.**
        - SET flag: `rootGitignoreModified = true`.
        - VERIFY change (`read_file .gitignore`). IF fails, HALT & Escalate.
    - GOTO Step A.3.
3.  **ADD SUBMODULE:**
    *   Execute `run_terminal_cmd git submodule add https://github.com/m0st4f4-hub/.cursor .cursor`.
    *   **Verify:**
        *   Execute `list_dir .`. Confirm `.cursor` AND `.gitmodules` exist.
        *   Execute `read_file .gitmodules`. Confirm it contains an entry for `[submodule ".cursor"]`.
        *   *If Verification Fails:* Attempt `run_terminal_cmd git submodule add --force https://github.com/m0st4f4-hub/.cursor .cursor` **ONCE** if a conflict was the likely cause (e.g., if Step A.1 removed an old directory). If it still fails, HALT.
    *   Proceed to **Step A.4**.
4.  **UPDATE SUBMODULE:**
    *   Execute `run_terminal_cmd git submodule update --init --recursive`.
    *   **Verify:** Execute `list_dir .cursor/rules`. Confirm critical rule files (e.g., `shared-core.mdc`) are present. Retry update **ONCE** if needed. If still fails, HALT.
    *   Proceed to **Phase 3**.

‚û°Ô∏è **Scenario B: Non-Git, Empty (`isGitRepo`: false, `isNotEmpty`: false)**
1.  **HANDLE EXISTING `.cursor`:**
    - IF `cursorDirExists` is true: **Log warning to Wiki.** EXECUTE: `run_terminal_cmd rm -rf .cursor` (or `Remove-Item -Recurse -Force .cursor`). VERIFY removal. IF fails, HALT & Escalate.
    - GOTO Step B.2.
2.  **DIRECT CLONE:**
    *   Execute `run_terminal_cmd git clone https://github.com/m0st4f4-hub/.cursor .cursor`.
    *   **Verify:** Execute `list_dir .cursor/rules`. Confirm critical rule files (e.g., `shared-core.mdc`) are present. If verification fails, HALT.
    *   Proceed to **Phase 3**.

‚û°Ô∏è **Scenario C: Non-Git, Not Empty (`isGitRepo`: false, `isNotEmpty`: true)**
*   **WARNING:** Requires manual intervention if `.cursor` exists.
1.  **HANDLE EXISTING `.cursor`:**
    - IF `cursorDirExists` is true: **Log critical warning to Wiki.** HALT. Report need for manual intervention via **Chat Trigger** to `Overmind`. DO NOT DELETE.
    - ELSE (`cursorDirExists` is false): GOTO Step C.2.
2.  **TEMP CLONE & MOVE:**
    *   Define temporary directory name: `temp_dir = "temp_ruleset_clone"`.
    *   Cleanup any previous temp dir: `run_terminal_cmd rm -rf temp_dir` (or `Remove-Item`).
    *   Clone into temp dir: `run_terminal_cmd git clone https://github.com/m0st4f4-hub/.cursor temp_dir`. **Verify** clone success (`list_dir temp_dir`).
    *   Initialize submodules within temp dir: `run_terminal_cmd "cd temp_dir && git submodule update --init --recursive && cd .."`. **Verify** (`list_dir temp_dir/.cursor/rules`).
    *   Move the cloned `.cursor` dir: `run_terminal_cmd mv temp_dir/.cursor .` (or `Move-Item`).
    *   **Verify:**
        *   `list_dir .` confirms `.cursor` exists at the root.
        *   `list_dir .cursor/rules` confirms critical rule files exist.
        *   If verification fails, HALT.
    *   Cleanup temp dir: `run_terminal_cmd rm -rf temp_dir` (or `Remove-Item`). **Verify** removal.
    *   Proceed to **Phase 3**.

### Phase 3: Common Configuration Steps (MANDATORY)
1.  **Configure Project Rules Directory:**
    *   Execute `list_dir .cursor/rules`. Check if `project` subdirectory exists.
    *   *If Not Exists:* Create it: `run_terminal_cmd mkdir .cursor/rules/project` (or `New-Item -ItemType Directory -Path .cursor\rules\project` on Windows).
    *   **Verify** creation using `list_dir .cursor/rules`. If verification fails, HALT.
2.  **Update Ruleset `.gitignore`:**
    *   Execute `read_file .cursor/.gitignore`. Handle potential non-existence.
    *   Check if the exact line `rules/project/` exists on its own line.
    *   *If Missing or Incorrect:* Use `edit_file` on `.cursor/.gitignore` to add or ensure `rules/project/` exists correctly on its own line.
    *   **Verify** the change using `read_file .cursor/.gitignore`. If verification fails, HALT.
3.  **Update/Restore Root `.gitignore` (Scenario A Only):**
    - IF `isGitRepo` is true:
        - IF `rootGitignoreModified` is true:
            - EXECUTE: `edit_file .gitignore` (Uncomment `# .cursor/` to `.cursor/`). **Log action to Wiki.**
            - VERIFY: `read_file .gitignore`. Confirm uncommented. IF fails, HALT & Escalate.
        - ELSE:
            *   Execute `read_file .gitignore`. Handle non-existence.
            *   Check for the exact line `.cursor/` (uncommented).
            *   *If Missing:* Use `edit_file` (create `.gitignore` if needed) to add `.cursor/` on a new line.
            *   **Verify** using `read_file .gitignore`. If verification fails, HALT.
4.  **FINAL VERIFICATION & HANDOFF:**
    *   EXECUTE: `list_dir .cursor/rules`. Confirm exists with `shared-core.mdc`, `project/`, `agents/`.
    *   OPTIONAL: EXECUTE `python tools/verify_environment.py` / `python tools/check_versions.py`.
    *   **Append success report to Wiki.**
    *   **Generate FINAL Chat Trigger to Overmind:** Send the success trigger as defined in `initialization-agent.md` (e.g., "Hey Overmind, Initialization successful. Ruleset ready. See wiki."). This completes the InitializationAgent's turn and hands off control.

## SUCCESS CRITERIA (MANDATORY)

Initialization succeeds **if and only if**:
*   All required steps for the determined scenario (A, B, or C) and Phase 3 were executed without triggering a HALT.
*   All **Verify** steps passed successfully.
*   The `.cursor/rules/` directory exists and contains the core structure (`project/`, `agents/`, core rule files).
*   If Scenario A, the Git submodule is correctly initialized or updated.
*   `.gitignore` files (`.cursor/.gitignore` and potentially root `.gitignore`) are configured correctly.
*   The final status (Success/Failure) is logged to the Knowledge Wiki and reported to `Overmind` via Chat Trigger.

## INPUTS & OUTPUTS

*   **Input:** Project workspace state (Git repo status, existing files/directories).
*   **Output:** Configured `.cursor/rules/` directory, potentially modified `.gitignore` files, updated Knowledge Wiki, final Chat Trigger to `Overmind`.

## TOOLS

*   `list_dir`, `read_file`, `edit_file`
*   `run_terminal_cmd` (for `git`, `rm`/`Remove-Item`, `mkdir`/`New-Item`, `mv`/`Move-Item`, `cd`)
*   `python tools/parse_git_status.py` (Recommended for Git status check)
*   `python tools/verify_environment.py` (Optional checks)
*   `python tools/check_versions.py` (Optional checks)
*   Wiki interaction tools
*   Framework Chat Mechanism

## ERROR HANDLING

*   Defined inline: Any **Verify** step failure MUST lead to immediate HALT, Wiki update, and Chat Trigger to `Overmind`.
*   Scenario C with existing `.cursor` requires explicit HALT and escalation.

## CONSTRAINTS & FORBIDDEN PATTERNS

*   MUST NOT skip verification steps.
*   MUST rely on tool output inspection, not just exit codes.
*   MUST handle potential non-existence of files (like `.gitignore`) gracefully.
*   MUST log specific errors to Wiki and HALT on any verification failure.
*   MUST NOT proceed past HALT state.

## EXAMPLES

*   N/A (Procedural document)

## REFERENCES

*   [`global-mandates.md`](./global-mandates.md)
*   [Agent Roles & Responsibilities](mdc:agent-roles.md) (`InitializationAgent`)
*   [Wiki Handling](mdc:wiki-handling.md)
*   [Core Execution Loop](mdc:execution-loop.md) (for context on agent operation)

## <a name="error-handling-initialization"></a>Error Handling (Initialization)
- On any HALT condition (verification failure):
  1. **Append** detailed error message to `knowledge-wiki.md` under `## ‚ö†Ô∏è Errors & Escalations`.
  2. **Generate FINAL Chat Trigger** to `Overmind`: "Hey Overmind, **ERROR** during initialization: [brief summary]. Halting procedure. See wiki for details." 