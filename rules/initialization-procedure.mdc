---
# Rule Definition Metadata (V1)
ruleId: initialization-procedure
ruleType: Procedure
title: Ruleset Initialization Procedure
description: Mandatory procedure executed by InitializationAgent to ensure the `.cursor/rules/` directory exists and is correctly configured (via Git submodule or direct clone).
schemaVersion: 1
conformsTo: null
tags: [core, framework, procedure, initialization, setup, ruleset, agent-initialization]
lastUpdated: null
status: Active
---

# INITIALIZATION PROCEDURE (MANDATORY)

**PURPOSE:** Ensure `.cursor/` ruleset exists and is correctly configured. Executed by `InitializationAgent`.

**CONTEXT:** This procedure is executed by the `InitializationAgent` after being activated by a **Chat Trigger** from `Overmind` (e.g., "Hey InitializationAgent, initialize project XYZ."). The agent **MUST** fetch its own rules via `fetch_rules` before proceeding.

**PRINCIPLES (MANDATORY):**
- **IDEMPOTENCY:** Repeated execution MUST yield same valid state.
- **VERIFICATION:** MUST confirm success via tool outputs (`list_dir`, `read_file`, `git status`, `parse_git_status.py`), NOT exit codes.
- **ERROR HANDLING:** On verification failure, MUST append error details to the **Knowledge Wiki** (`## ‚ö†Ô∏è Errors & Escalations`), HALT procedure, and trigger `Overmind` via **Chat Trigger**. See [Error Handling](#error-handling-initialization).
- **TOOL USAGE:** MUST use standard tools/Git commands.
- **WIKI LOGGING:** All significant actions, warnings, and final outcomes **MUST** be appended to the **Knowledge Wiki** under appropriate sections (e.g., `## üõ†Ô∏è Actions & Code Changes`, `## ‚ö†Ô∏è Errors & Escalations`).

## WORKFLOW (MANDATORY)

### Phase 0: Fetch Rules (NEW)
1.  **FETCH OWN RULES:** Execute `fetch_rules` for `initialization-agent.md`.
2.  **READ WIKI:** Execute `read_file` on `<requestId>-wiki.md` for context.

### Phase 1: Determine Project State
1.  **Check Git Status:**
    *   Verify Git availability (e.g., `python tools/verify_environment.py --check git`).
    *   Execute `python tools/parse_git_status.py` or `git rev-parse --is-inside-work-tree`.
    *   Record result: `isGitRepo` (true/false).
2.  **Check `.cursor` Directory Existence:**
    *   Execute `list_dir .`.
    *   Record result: `cursorDirExists` (true/false).
3.  **Check if Directory is Empty (Only if Not a Git Repo):**
    *   *Condition:* Only if `isGitRepo` is false.
    *   Execute `list_dir .`. Check for *any* files or folders other than potentially `.cursor` or `.git`.
    *   Record result: `isNotEmpty` (true/false).

### Phase 2: Execute Scenario Workflow

‚û°Ô∏è **Scenario A: Git Repository (`isGitRepo`: true)**
1.  **HANDLE EXISTING `.cursor`:**
    - IF `cursorDirExists` is true:
        - EXECUTE: `git submodule status .cursor | cat`.
        - IF Valid Submodule: GOTO Step A.4.
        - IF Not Submodule/Error: **Log warning to Wiki.** EXECUTE: `run_terminal_cmd rm -rf .cursor` (or `Remove-Item -Recurse -Force .cursor`). VERIFY removal (`list_dir .`). IF fails, HALT & Escalate. GOTO Step A.2.
    - ELSE (`cursorDirExists` is false): GOTO Step A.2.
2.  **CHECK/MODIFY ROOT `.gitignore`:**
    - SET flag: `rootGitignoreModified = false`.
    - EXECUTE: `read_file .gitignore` (Handle non-existence).
    - SEARCH for exact line `.cursor/`.
    - IF found:
        - EXECUTE: `edit_file .gitignore` (Comment out: `# .cursor/`). **Log action to Wiki.**
        - SET flag: `rootGitignoreModified = true`.
        - VERIFY change (`read_file .gitignore`). IF fails, HALT & Escalate.
    - GOTO Step A.3.
3.  **ADD SUBMODULE:**
    *   Execute `run_terminal_cmd git submodule add https://github.com/m0st4f4-hub/.cursor .cursor`.
    *   **Verify:**
        *   Execute `list_dir .`. Confirm `.cursor` AND `.gitmodules` exist.
        *   Execute `read_file .gitmodules`. Confirm it contains an entry for `[submodule ".cursor"]`.
        *   *If Verification Fails:* Attempt `run_terminal_cmd git submodule add --force https://github.com/m0st4f4-hub/.cursor .cursor` **ONCE** if a conflict was the likely cause (e.g., if Step A.1 removed an old directory). If it still fails, HALT.
    *   Proceed to **Step A.4**.
4.  **UPDATE SUBMODULE:**
    *   Execute `run_terminal_cmd git submodule update --init --recursive`.
    *   **Verify:** Execute `list_dir .cursor/rules`. Confirm critical rule files (e.g., `shared-core.mdc`) are present. Retry update **ONCE** if needed. If still fails, HALT.
    *   Proceed to **Phase 3**.

‚û°Ô∏è **Scenario B: Non-Git, Empty (`isGitRepo`: false, `isNotEmpty`: false)**
1.  **HANDLE EXISTING `.cursor`:**
    - IF `cursorDirExists` is true: **Log warning to Wiki.** EXECUTE: `run_terminal_cmd rm -rf .cursor` (or `Remove-Item -Recurse -Force .cursor`). VERIFY removal. IF fails, HALT & Escalate.
    - GOTO Step B.2.
2.  **DIRECT CLONE:**
    *   Execute `run_terminal_cmd git clone https://github.com/m0st4f4-hub/.cursor .cursor`.
    *   **Verify:** Execute `list_dir .cursor/rules`. Confirm critical rule files (e.g., `shared-core.mdc`) are present. If verification fails, HALT.
    *   Proceed to **Phase 3**.

‚û°Ô∏è **Scenario C: Non-Git, Not Empty (`isGitRepo`: false, `isNotEmpty`: true)**
*   **WARNING:** Requires manual intervention if `.cursor` exists.
1.  **HANDLE EXISTING `.cursor`:**
    - IF `cursorDirExists`