---
description: "[TODO: Add description]"
globs:
  - "*.*"
alwaysApply: false
---
---
description: "Mandatory procedure for InitializationAgent to set up or verify the framework ruleset."
globs: ["*"]
alwaysApply: true
---

# Framework Initialization Procedure

## üéØ Overview

This document dictates the **mandatory, self-contained initialization procedure** for the [`InitializationAgent`](mdc:rules-md/agent-roles.md#initializationagent). Execute these steps precisely to ensure the agent framework's foundational ruleset (`.cursor/` directory) is present and correctly configured.

Reference [shared-core.mdc](mdc:rules-md/shared-core.md) for core definitions.

## üîë Core Principles

Adhere strictly to these principles:

1.  **Idempotency:** Execution **MUST** result in the same valid end state, regardless of the number of times run.
    ```pseudocode
    // @examples/idempotency.pseudocode
    // Define Result Structure: { success: boolean, state: 'new' | 'updated' | 'verified', changes: list_of_strings }
    
    // Function: initializeFramework
    // Purpose: Ensure idempotent setup.
    // Returns: Result Structure
    // Steps:
    //   currentState = determineProjectState()
    //   result = executeScenario(currentState)
    //   verifyResult(result) // Halts on failure
    //   return result
    // End Function
    ```

2.  **Verification:** **MUST** verify each step using tool outputs (`list_dir`, `read_file`, `git status`, `tools/parse_git_status.py`). Do **NOT** rely solely on command exit codes. Halt immediately on verification failure.
    ```pseudocode
    // @examples/verification.pseudocode
    // Define Verification Step Structure: { tool_used: string, verification_logic: function, error_message: string }
    
    // Example Verification Steps List:
    //   - { tool: "list_dir", check: check_directory_exists(".cursor/rules"), error: "Rules dir missing" }
    //   - { tool: "git status", check: check_git_status_is_clean(), error: "Uncommitted changes" }
    
    // Function: runVerification(step)
    // Purpose: Execute a verification check.
    // Steps:
    //   success = step.verification_logic()
    //   if not success:
    //     logError(step.error_message)
    //     haltProcedure()
    // End Function
    ```

3.  **Error Handling:** If verification fails, **MUST** log the specific error and **HALT** the procedure immediately. Report failure to [`Overmind`](mdc:rules-md/agent-roles.md#overmind) via the log.
    ```pseudocode
    // @examples/error-handling.pseudocode
    // Define Error Structure: { phase: string, error_details: string }
    
    // Function: handleProcedureError(error)
    // Purpose: Log error and halt.
    // Steps:
    //   logErrorToRequestLog(error.phase, error.error_details)
    //   setNextAgent("Overmind")
    //   setHandoffMessage("Initialization failed during phase: " + error.phase + ". Reason: " + error.error_details)
    //   haltProcedure()
    // End Function
    ```

4.  **Tool Usage:** **MUST** prefer standard tools (`list_dir`, `read_file`, `edit_file`) and core Git commands (executed via `run_terminal_cmd`) over complex shell scripts.
    ```pseudocode
    // @examples/tool-usage.pseudocode
    // List of Preferred Tools:
    //   - list_dir
    //   - read_file
    //   - edit_file
    //   - run_terminal_cmd (for basic git commands like 'git rev-parse', 'git submodule')
    //   - tools/parse_git_status.py (via run_terminal_cmd)
    //   - tools/verify_environment.py (via run_terminal_cmd)
    ```

## üìã Phase 1: Determine Project State

Execute these steps sequentially to determine the project's current state.

### Step 1.1: Check Git Status
*   **Action:** Execute `run_terminal_cmd git rev-parse --is-inside-work-tree | cat` or `run_terminal_cmd python tools/parse_git_status.py`. Capture the output.
*   **Record:** Note `isGitRepo` (true/false) based on output.
    ```pseudocode
    // @examples/git-check.pseudocode
    // Define Git State Structure: { isGitRepo: boolean, /* other potential fields */ }
    
    // Function: checkGitStatus
    // Purpose: Determine if the workspace is a Git repository.
    // Returns: Git State Structure
    // Steps:
    //   // Use run_terminal_cmd with 'git rev-parse' or 'python tools/parse_git_status.py'
    //   command_output = runCommand("...")
    //   isRepo = parseCommandOutputForGitRepoStatus(command_output)
    //   return { isGitRepo: isRepo }
    // End Function
    ```

### Step 1.2: Check `.cursor` Directory Existence
*   **Action:** Execute `list_dir .`.
*   **Record:** Note `cursorDirExists` (true/false) based on whether `.cursor` is present in the output.
    ```pseudocode
    // @examples/cursor-check.pseudocode
    // Define Cursor State Structure: { exists: boolean, /* other potential fields */ }
    
    // Function: checkCursorDir
    // Purpose: Check if .cursor directory exists at the root.
    // Returns: Cursor State Structure
    // Steps:
    //   directory_listing = listDir(".")
    //   exists = ".cursor" in directory_listing
    //   return { exists: exists }
    // End Function
    ```

### Step 1.3: Check if Directory is Empty (Conditional)
*   **Condition:** Execute **only if** `isGitRepo` is false.
*   **Action:** Execute `list_dir .`.
*   **Record:** Note `isNotEmpty` (true/false) based on whether the listing contains *any* files/folders other than potentially `.cursor` or `.git`.
    ```pseudocode
    // @examples/dir-check.pseudocode
    // Define Directory State Structure: { isNotEmpty: boolean, /* other fields */ }
    
    // Function: checkDirContents (only if not isGitRepo)
    // Purpose: Check if the directory contains relevant user files.
    // Returns: Directory State Structure
    // Steps:
    //   contents = listDir(".")
    //   filtered_contents = remove entries like '.git', '.cursor' from contents
    //   isNotEmpty = length(filtered_contents) > 0
    //   return { isNotEmpty: isNotEmpty }
    // End Function
    ```

## üìã Phase 2: Execute Scenario-Specific Workflow

Based on the state determined in Phase 1, execute **exactly one** of the following scenarios (A, B, or C).

### Scenario A: Project is a Git Repository (`isGitRepo` is true)

Execute these steps sequentially:

1.  **Handle Existing `.cursor`:**
    *   If `cursorDirExists` is false: Proceed to Step A.2.
    *   If `cursorDirExists` is true:
        *   **Action:** Execute `run_terminal_cmd git submodule status .cursor | cat`.
        *   **Check:** Analyze output. If it indicates a valid registered submodule, proceed to **Step A.4 (Update Submodule)**.
        *   **If Not Submodule:** Log warning. **Action:** Execute `run_terminal_cmd rm -rf .cursor` (or `Remove-Item -Recurse -Force .cursor` on Windows). **Verification:** Execute `list_dir .` and confirm `.cursor` is removed. If verification fails, **HALT** (report error to Overmind).
        *   Proceed to **Step A.2**.
2.  **Check & Temporarily Modify Root `.gitignore`:**
    *   Set flag `rootGitignoreModified = false`.
    *   **Action:** Execute `read_file .gitignore` (handle potential non-existence gracefully).
    *   **Check:** Search content for the exact line `.cursor/`.
    *   **If Found:**
        *   **Action:** Use `edit_file` to comment out the line (e.g., `# .cursor/`). Log this action.
        *   **Verification:** Execute `read_file .gitignore`. Confirm the line is commented. If verification fails, **HALT** (report error).
        *   Set `rootGitignoreModified = true`.
    *   Proceed to **Step A.3**.
3.  **Add Submodule:**
    *   **Action:** Execute `run_terminal_cmd git submodule add https://github.com/m0st4f4-hub/.cursor .cursor`.
    *   **Verification:** Execute `list_dir .`. Confirm `.cursor` AND `.gitmodules` exist. Execute `read_file .gitmodules`. Confirm `[submodule ".cursor"]` entry exists. If verification fails, attempt `run_terminal_cmd git submodule add --force ...` *once* if conflicts are likely (e.g., after Step A.1 removal). If still fails, **HALT** (report error).
    *   Proceed to **Step A.4**.
4.  **Update Submodule:**
    *   **Action:** Execute `run_terminal_cmd git submodule update --init --recursive`.
    *   **Verification:** Execute `list_dir .cursor/rules`. Confirm essential rule files (e.g., `shared-core.mdc`) are present. Retry update once if needed. If still fails, **HALT** (report error).
    *   Proceed to **Phase 3**.

    ```pseudocode
    // @examples/git-scenario.pseudocode
    // Function: handleGitRepoScenario
    // Purpose: Initialize framework in an existing Git repo.
    // Steps:
    //   if checkCursorDir().exists:
    //     if checkIsSubmodule(".cursor"):
    //       // Proceed to Step A.4
    //     else:
    //       logWarning("Existing .cursor is not a submodule. Attempting removal.")
    //       runCommand("rm -rf .cursor") // Or Windows equivalent
    //       verifyCursorRemoved() // Halts on failure
    //       // Proceed to Step A.2
    //   // else: Proceed to Step A.2
    //   
    //   // Step A.2
    //   gitignoreContent = readFile(".gitignore") // Handle non-existence
    //   rootGitignoreModified = false
    //   if ".cursor/" in gitignoreContent:
    //      editFile(".gitignore", comment_out_line, ".cursor/")
    //      verifyGitignoreCommented() // Halts on failure
    //      rootGitignoreModified = true
    //   
    //   // Step A.3
    //   runCommand("git submodule add <repo_url> .cursor")
    //   verifySubmoduleAdded() // Halts on failure. Includes --force retry logic.
    //   
    //   // Step A.4
    //   runCommand("git submodule update --init --recursive")
    //   verifySubmoduleUpdated() // Halts on failure. Includes retry logic.
    //   
    //   // Proceed to Phase 3
    // End Function
    ```

### Scenario B: Project is NOT Git Repo AND is Empty (`isGitRepo` false, `isNotEmpty` false)

Execute these steps sequentially:

1.  **Handle Existing `.cursor`:**
    *   If `cursorDirExists` is true: Log warning. **Action:** Execute `run_terminal_cmd rm -rf .cursor` (or `Remove-Item`). **Verification:** Execute `list_dir .` and confirm removal. If fails, **HALT**.
    *   Proceed to **Step B.2**.
2.  **Direct Clone:**
    *   **Action:** Execute `run_terminal_cmd git clone https://github.com/m0st4f4-hub/.cursor .cursor`.
    *   **Verification:** Execute `list_dir .cursor/rules`. Confirm essential rule files (e.g., `shared-core.mdc`). If fails, **HALT**.
    *   Proceed to **Phase 3**.

    ```pseudocode
    // @examples/empty-scenario.pseudocode
    // Function: handleEmptyDirScenario
    // Purpose: Initialize framework in an empty non-Git directory.
    // Steps:
    //   if checkCursorDir().exists:
    //     logWarning("Found existing .cursor. Attempting removal.")
    //     runCommand("rm -rf .cursor")
    //     verifyCursorRemoved() // Halts on failure
    //     
    //   // Step B.2
    //   runCommand("git clone <repo_url> .cursor")
    //   verifyCloneSuccess() // Halts on failure
    //   
    //   // Proceed to Phase 3
    // End Function
    ```

### Scenario C: Project is NOT Git Repo AND is NOT Empty (`isGitRepo` false, `isNotEmpty` true)

**Warning:** Complex scenario. Manual intervention likely needed if errors occur.
Execute these steps sequentially:

1.  **Handle Existing `.cursor`:**
    *   If `cursorDirExists` is true: Log critical warning. **HALT**. Report need for manual intervention. **Do not automatically delete.**
    *   If `cursorDirExists` is false: Proceed to **Step C.2**.
2.  **Temp Clone & Move:**
    *   Define `temp_dir` = `temp_ruleset_clone`.
    *   **Action (Cleanup):** Execute `run_terminal_cmd rm -rf temp_dir` (or `Remove-Item`).
    *   **Action (Clone):** Execute `run_terminal_cmd git clone https://github.com/m0st4f4-hub/.cursor temp_dir`. **Verification:** Check clone success. If fails, **HALT**.
    *   **Action (Init Submodules):** Execute `run_terminal_cmd cd temp_dir && git submodule update --init --recursive && cd ..`. **Verification:** Check submodule success. If fails, **HALT**.
    *   **Action (Move):** Execute `run_terminal_cmd mv temp_dir/.cursor .` (or `Move-Item`).
    *   **Verification:** Execute `list_dir .`. Confirm `.cursor` exists. Execute `list_dir .cursor/rules`. Confirm essential files. If fails, **HALT**.
    *   **Action (Cleanup):** Execute `run_terminal_cmd rm -rf temp_dir` (or `Remove-Item`). **Verification:** Confirm temp dir removal. If fails, log warning but proceed.
    *   Proceed to **Phase 3**.

    ```pseudocode
    // @examples/nonempty-scenario.pseudocode
    // Function: handleNonEmptyDirScenario
    // Purpose: Initialize framework in a non-empty non-Git directory.
    // Steps:
    //   if checkCursorDir().exists:
    //     logCritical("Existing .cursor found in non-empty, non-Git project. HALTING.")
    //     reportErrorToOvermind("Manual intervention required: Existing .cursor directory.")
    //     haltProcedure()
    //     
    //   // Step C.2
    //   temp_dir = "temp_ruleset_clone"
    //   runCommand("rm -rf " + temp_dir) // Cleanup previous attempt
    //   runCommand("git clone <repo_url> " + temp_dir)
    //   verifyCloneSuccess() // Halts on failure
    //   runCommand("cd " + temp_dir + " && git submodule update --init --recursive && cd ..")
    //   verifySubmoduleUpdated() // Halts on failure
    //   runCommand("mv " + temp_dir + "/.cursor .") // Or Move-Item
    //   verifyMoveSuccess() // Halts on failure
    //   runCommand("rm -rf " + temp_dir)
    //   verifyCleanupSuccess() // Log warning on failure, but continue
    //   
    //   // Proceed to Phase 3
    // End Function
    ```

## üìã Phase 3: Common Configuration Steps

Execute these steps after successfully completing one scenario from Phase 2.

### Step 3.1: Configure Project Directory
*   **Action:** Execute `list_dir .cursor/rules`.
*   **Check:** See if `project` subdirectory exists.
*   **If Not Found:** **Action:** Execute `run_terminal_cmd mkdir .cursor/rules/project` (or `New-Item` on Windows). **Verification:** Execute `list_dir .cursor/rules`. Confirm `project` dir exists. If fails, **HALT**.
    ```pseudocode
    // @examples/project-config.pseudocode
    // Function: configureProjectDirectory
    // Purpose: Ensure .cursor/rules/project directory exists.
    // Steps:
    //   rules_listing = listDir(".cursor/rules")
    //   if "project" not in rules_listing:
    //     runCommand("mkdir .cursor/rules/project") // Or New-Item
    //     verifyProjectDirCreated() // Halts on failure
    // End Function
    ```

### Step 3.2: Update Ruleset `.gitignore`
*   **Action:** Execute `read_file .cursor/.gitignore` (handle non-existence).
*   **Check:** Determine if the exact line `rules/project/` exists on its own line.
*   **If Missing/Incorrect:** **Action:** Use `edit_file` on `.cursor/.gitignore` to add or fix the line `rules/project/`. **Verification:** Execute `read_file .cursor/.gitignore`. Confirm the line exists correctly. If fails, **HALT**.
    ```pseudocode
    // @examples/ruleset-gitignore.pseudocode
    // Function: updateRulesetGitignore
    // Purpose: Ensure rules/project/ is ignored within the ruleset itself.
    // Steps:
    //   ruleset_gitignore = readFile(".cursor/.gitignore") // Handle non-existence
    //   if "rules/project/" not correctly present in ruleset_gitignore:
    //     editFile(".cursor/.gitignore", add_or_fix_line, "rules/project/")
    //     verifyRulesetGitignoreUpdated() // Halts on failure
    // End Function
    ```

### Step 3.3: Update/Restore Root `.gitignore` (Scenario A only)
*   **Condition:** Execute only if `isGitRepo` is true (determined in Phase 1).
*   **If `rootGitignoreModified` is true:**
    *   **Action:** Use `edit_file` on `.gitignore` to change `# .cursor/` back to `.cursor/`. Log this action.
    *   **Verification:** Execute `read_file .gitignore`. Confirm `.cursor/` is uncommented. If fails, **HALT**.
*   **Else (if `rootGitignoreModified` is false):**
    *   **Action:** Execute `read_file .gitignore` (handle non-existence).
    *   **Check:** See if uncommented `.cursor/` line exists.
    *   **If Missing:** **Action:** Use `edit_file` on `.gitignore` (create if needed) to add `.cursor/` on a new line.
    *   **Verification:** Execute `read_file .gitignore`. Confirm `.cursor/` line exists. If fails, **HALT**.
    ```pseudocode
    // @examples/root-gitignore.pseudocode
    // Function: updateRootGitignore (only if isGitRepo)
    // Purpose: Ensure .cursor/ is appropriately handled in the root .gitignore.
    // Input: rootGitignoreModified (boolean flag from Step A.2)
    // Steps:
    //   if rootGitignoreModified:
    //     editFile(".gitignore", uncomment_line, "# .cursor/")
    //     verifyRootGitignoreRestored() // Halts on failure
    //   else:
    //     root_gitignore = readFile(".gitignore") // Handle non-existence
    //     if ".cursor/" not present in root_gitignore:
    //       editFile(".gitignore", add_line, ".cursor/")
    //       verifyRootGitignoreAdded() // Halts on failure
    // End Function
    ```

### Step 3.4: Final Verification
*   **Action:** Execute `list_dir .cursor/rules`.
*   **Verification:** Confirm expected structure (e.g., `shared-core.mdc`, `project/`, `agents/` exist). If fails, **HALT**.
*   **Optional Action:** Execute `run_terminal_cmd python tools/verify_environment.py` or `python tools/check_versions.py` for extra checks.
*   **Report:** Log success to [`Overmind`](mdc:rules-md/agent-roles.md#overmind), setting `nextAgent: "Overmind"` and appropriate `handoffMessage`. If any step halted, failure should have already been reported.
    ```pseudocode
    // @examples/final-verify.pseudocode
    // Function: finalVerificationAndReport
    // Purpose: Perform final checks and report success to Overmind.
    // Steps:
    //   listing = listDir(".cursor/rules")
    //   verifyExpectedStructure(listing) // Halts on failure
    //   
    //   // Optional: runCommand("python tools/verify_environment.py")
    //   
    //   // If execution reaches here, all steps passed.
    //   logSuccessToRequestLog("Initialization completed successfully.")
    //   setNextAgent("Overmind")
    //   setHandoffMessage("Framework initialization successful.")
    // End Function
    ```

## üö® Error Recovery

*   **Verification Failures:** Any verification step failing **MUST** trigger an immediate **HALT**. The agent **MUST** log the specific error and report failure to [`Overmind`](mdc:rules-md/agent-roles.md#overmind) via the log.
*   **Tool Execution Errors:** If a `run_terminal_cmd` fails unexpectedly, attempt recovery if sensible (e.g., the `git submodule add --force` retry), otherwise **HALT** and report.

## üìã Success Criteria

Initialization is successful **ONLY IF**: 
1.  All required steps for the determined scenario (A, B, or C) completed without halting.
2.  All verification checks within those steps passed.
3.  The `.cursor/rules/` directory exists with the expected core structure (including `shared-core.mdc`, `agents/`, `project/`).
4.  Git submodule is correctly configured (Scenario A).
5.  `.gitignore` files are correctly configured.
6.  Success is logged and reported to `Overmind`.

## ‚ö†Ô∏è Deprecated Patterns (Strictly Forbidden)

*   Manual directory creation/deletion *without* verification.
*   Executing Git commands via `run_terminal_cmd` *without* subsequent verification steps.
*   Waiting for user prompts or confirmations.
*   Using hardcoded paths without checking existence or state first. 