---
# Rule Definition Metadata (V1)
ruleId: initialization-procedure
ruleType: Procedure
title: Ruleset Initialization Procedure
description: Mandatory procedure executed by InitializationAgent to ensure the `.cursor/rules/` directory exists and is correctly configured (via Git submodule or direct clone).
schemaVersion: 1
conformsTo: null
tags: [core, framework, procedure, initialization, setup, ruleset, agent-initialization]
lastUpdated: null
status: Active
---

# ⚙️ Ruleset Initialization Procedure

## 1. PURPOSE & OBJECTIVES

This document defines the **single, mandatory procedure** for ensuring the agent ruleset directory (`.cursor/rules/`) exists and is correctly configured within the project workspace. This procedure MUST be executed by the `InitializationAgent` as its primary function.

## 2. CORE BEHAVIOR & PRINCIPLES (MANDATORY)

*   **Idempotency:** Executing this procedure multiple times MUST result in the same valid end state.
*   **Verification-Driven:** Success MUST be determined by verifying the output of tools (`list_dir`, `read_file`, `git status` via `parse_git_status.py`), not just command exit codes.
*   **Error Handling:** On any verification failure, the procedure MUST HALT immediately, update the Knowledge Wiki (`## ⚠️ Errors & Escalations`) with specific failure details, and trigger `Overmind` via Chat Trigger.
*   **Tool Usage:** Standard framework tools (`list_dir`, `read_file`, `edit_file`) and core Git commands (executed via `run_terminal_cmd`) MUST be preferred over complex shell scripting. Use helper scripts like `parse_git_status.py` or `verify_environment.py` where appropriate.
*   **Agent:** This procedure is executed exclusively by the `InitializationAgent`.

## 3. ACTION SEQUENCE / WORKFLOW (MANDATORY)

The `InitializationAgent` MUST follow these phases precisely:

### Phase 1: Determine Project State
1.  **Check Git Status:**
    *   Verify Git availability (e.g., `python tools/verify_environment.py --check git`).
    *   Execute `python tools/parse_git_status.py` or `git rev-parse --is-inside-work-tree | cat`.
    *   Record result: `isGitRepo` (true/false).
2.  **Check `.cursor` Directory Existence:**
    *   Execute `list_dir .`.
    *   Record result: `cursorDirExists` (true/false).
3.  **Check if Directory is Empty (Only if Not a Git Repo):**
    *   *Condition:* Only if `isGitRepo` is false.
    *   Execute `list_dir .`. Check for *any* files or folders other than potentially `.cursor` or `.git`.
    *   Record result: `isNotEmpty` (true/false).

### Phase 2: Execute Scenario-Specific Workflow

➡️ **Scenario A: Project is a Git Repository (`isGitRepo` is true)**

1.  **Handle Existing `.cursor` Directory:**
    *   *Condition:* If `cursorDirExists` is true.
    *   Execute `git submodule status .cursor | cat`.
    *   *If Output Indicates Valid Submodule:* Proceed to **Step A.4 (Update Submodule)**.
    *   *If Output Indicates Not a Submodule or Error:*
        *   Log warning to Wiki.
        *   Attempt removal: `run_terminal_cmd rm -rf .cursor` (or `Remove-Item -Recurse -Force .cursor` on Windows).
        *   **Verify** removal using `list_dir .`. If verification fails, HALT.
        *   Proceed to **Step A.2**.
    *   *Condition:* If `cursorDirExists` is false: Proceed to **Step A.2**.
2.  **Check & Temporarily Modify Root `.gitignore`:**
    *   Initialize flag: `rootGitignoreModified = false`.
    *   Execute `read_file .gitignore`. Handle potential non-existence gracefully (treat as empty).
    *   Search content for the exact line `.cursor/` (uncommented).
    *   *If Found:*
        *   Execute `edit_file` on `.gitignore` to comment out the line (e.g., change to `# .cursor/`). Log action to Wiki.
        *   Set `rootGitignoreModified = true`.
        *   **Verify** the change using `read_file .gitignore`. If verification fails, HALT.
    *   Proceed to **Step A.3**.
3.  **Add Submodule:**
    *   Execute `run_terminal_cmd git submodule add https://github.com/m0st4f4-hub/.cursor .cursor`.
    *   **Verify:**
        *   Execute `list_dir .`. Confirm `.cursor` AND `.gitmodules` exist.
        *   Execute `read_file .gitmodules`. Confirm it contains an entry for `[submodule ".cursor"]`.
        *   *If Verification Fails:* Attempt `run_terminal_cmd git submodule add --force https://github.com/m0st4f4-hub/.cursor .cursor` **ONCE** if a conflict was the likely cause (e.g., if Step A.1 removed an old directory). If it still fails, HALT.
    *   Proceed to **Step A.4**.
4.  **Update Submodule:**
    *   Execute `run_terminal_cmd git submodule update --init --recursive`.
    *   **Verify:** Execute `list_dir .cursor/rules`. Confirm critical rule files (e.g., `shared-core.mdc`) are present. Retry update **ONCE** if needed. If still fails, HALT.
    *   Proceed to **Phase 3**.

➡️ **Scenario B: Project is NOT a Git Repository AND is Empty (`isGitRepo` is false, `isNotEmpty` is false)**

1.  **Handle Existing `.cursor` Directory:**
    *   *Condition:* If `cursorDirExists` is true.
    *   Log warning to Wiki.
    *   Attempt removal: `run_terminal_cmd rm -rf .cursor` (or `Remove-Item -Recurse -Force .cursor`).
    *   **Verify** removal using `list_dir .`. If verification fails, HALT.
    *   Proceed to **Step B.2**.
2.  **Direct Clone:**
    *   Execute `run_terminal_cmd git clone https://github.com/m0st4f4-hub/.cursor .cursor`.
    *   **Verify:** Execute `list_dir .cursor/rules`. Confirm critical rule files (e.g., `shared-core.mdc`) are present. If verification fails, HALT.
    *   Proceed to **Phase 3**.

➡️ **Scenario C: Project is NOT a Git Repository AND is NOT Empty (`isGitRepo` is false, `isNotEmpty` is true)**

*   **Warning:** This is a potentially problematic state. Manual intervention might be required if `.cursor` already exists.
1.  **Handle Existing `.cursor` Directory:**
    *   *Condition:* If `cursorDirExists` is true.
    *   Log CRITICAL warning to Wiki indicating potential conflict with existing non-Git project files.
    *   **HALT.** Report the situation and the need for manual intervention/confirmation to `Overmind`. **DO NOT** automatically delete the existing `.cursor` directory.
    *   *Condition:* If `cursorDirExists` is false: Proceed to **Step C.2**.
2.  **Temporary Clone & Move:**
    *   Define temporary directory name: `temp_dir = "temp_ruleset_clone"`.
    *   Cleanup any previous temp dir: `run_terminal_cmd rm -rf temp_dir` (or `Remove-Item`).
    *   Clone into temp dir: `run_terminal_cmd git clone https://github.com/m0st4f4-hub/.cursor temp_dir`. **Verify** clone success (`list_dir temp_dir`).
    *   Initialize submodules within temp dir: `run_terminal_cmd "cd temp_dir && git submodule update --init --recursive && cd .."`. **Verify** (`list_dir temp_dir/.cursor/rules`).
    *   Move the cloned `.cursor` dir: `run_terminal_cmd mv temp_dir/.cursor .` (or `Move-Item`).
    *   **Verify:**
        *   `list_dir .` confirms `.cursor` exists at the root.
        *   `list_dir .cursor/rules` confirms critical rule files exist.
        *   If verification fails, HALT.
    *   Cleanup temp dir: `run_terminal_cmd rm -rf temp_dir` (or `Remove-Item`). **Verify** removal.
    *   Proceed to **Phase 3**.

### Phase 3: Common Configuration Steps (MANDATORY for ALL Scenarios)
1.  **Configure Project Rules Directory:**
    *   Execute `list_dir .cursor/rules`. Check if `project` subdirectory exists.
    *   *If Not Exists:* Create it: `run_terminal_cmd mkdir .cursor/rules/project` (or `New-Item -ItemType Directory -Path .cursor\rules\project` on Windows).
    *   **Verify** creation using `list_dir .cursor/rules`. If verification fails, HALT.
2.  **Update Ruleset `.gitignore`:**
    *   Execute `read_file .cursor/.gitignore`. Handle potential non-existence.
    *   Check if the exact line `rules/project/` exists on its own line.
    *   *If Missing or Incorrect:* Use `edit_file` on `.cursor/.gitignore` to add or ensure `rules/project/` exists correctly on its own line.
    *   **Verify** the change using `read_file .cursor/.gitignore`. If verification fails, HALT.
3.  **Update/Restore Root `.gitignore` (Scenario A Only):**
    *   *Condition:* Only if `isGitRepo` is true.
    *   *If `rootGitignoreModified` is true (from Step A.2):*
        *   Use `edit_file` on `.gitignore` to uncomment the `# .cursor/` line back to `.cursor/`. Log action to Wiki.
        *   **Verify** using `read_file .gitignore`. Confirm `.cursor/` is present and uncommented. If verification fails, HALT.
    *   *Else (if `.cursor/` wasn't originally in root `.gitignore` or was already present/commented differently):*
        *   Execute `read_file .gitignore`. Handle non-existence.
        *   Check for the exact line `.cursor/` (uncommented).
        *   *If Missing:* Use `edit_file` (create `.gitignore` if needed) to add `.cursor/` on a new line.
        *   **Verify** using `read_file .gitignore`. If verification fails, HALT.
4.  **Final Verification & Reporting:**
    *   Execute `list_dir .cursor/rules`. Confirm it exists and contains expected core structure (e.g., `shared-core.mdc`, `project/`, `agents/`).
    *   *Optional:* Execute environment checks like `python tools/verify_environment.py` or `python tools/check_versions.py`. Log results to Wiki.
    *   Update Knowledge Wiki (`## Actions & Code Changes` or `## Errors & Escalations`) with a summary of the procedure outcome (Success or Failure with reason).
    *   **FINAL ACTION:** Trigger `Overmind` via Chat Trigger, indicating completion status: "Hey Overmind, Initialization procedure completed [successfully / with HALT state]. See wiki for details."

## 4. SUCCESS CRITERIA (MANDATORY)

Initialization succeeds **if and only if**:
*   All required steps for the determined scenario (A, B, or C) and Phase 3 were executed without triggering a HALT.
*   All **Verify** steps passed successfully.
*   The `.cursor/rules/` directory exists and contains the core structure (`project/`, `agents/`, core rule files).
*   If Scenario A, the Git submodule is correctly initialized or updated.
*   `.gitignore` files (`.cursor/.gitignore` and potentially root `.gitignore`) are configured correctly.
*   The final status (Success/Failure) is logged to the Knowledge Wiki and reported to `Overmind` via Chat Trigger.

## 5. INPUTS & OUTPUTS

*   **Input:** Project workspace state (Git repo status, existing files/directories).
*   **Output:** Configured `.cursor/rules/` directory, potentially modified `.gitignore` files, updated Knowledge Wiki, final Chat Trigger to `Overmind`.

## 6. TOOLS

*   `list_dir`, `read_file`, `edit_file`
*   `run_terminal_cmd` (for `git`, `rm`/`Remove-Item`, `mkdir`/`New-Item`, `mv`/`Move-Item`, `cd`)
*   `python tools/parse_git_status.py` (Recommended for Git status check)
*   `python tools/verify_environment.py` (Optional checks)
*   `python tools/check_versions.py` (Optional checks)
*   Wiki interaction tools
*   Framework Chat Mechanism

## 7. ERROR HANDLING

*   Defined inline: Any **Verify** step failure MUST lead to immediate HALT, Wiki update, and Chat Trigger to `Overmind`.
*   Scenario C with existing `.cursor` requires explicit HALT and escalation.

## 8. CONSTRAINTS & FORBIDDEN PATTERNS

*   MUST NOT skip verification steps.
*   MUST rely on tool output inspection, not just exit codes.
*   MUST handle potential non-existence of files (like `.gitignore`) gracefully.
*   MUST log specific errors to Wiki and HALT on any verification failure.
*   MUST NOT proceed past HALT state.

## 9. EXAMPLES

*   N/A (Procedural document)

## 10. REFERENCES

*   [`global-mandates.md`](./global-mandates.md)
*   [Agent Roles & Responsibilities](mdc:agent-roles.md) (`InitializationAgent`)
*   [Wiki Handling](mdc:wiki-handling.md)
*   [Core Execution Loop](mdc:execution-loop.md) (for context on agent operation) 